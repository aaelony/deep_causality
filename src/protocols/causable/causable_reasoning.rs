/*
 * Copyright (c) 2023. Marvin Hansen <marvin.hansen@gmail.com> All rights reserved.
 */
use crate::errors::CausalityError;
use crate::prelude::*;
use crate::types::alias_types::NumericalValue;

pub trait CausableReasoning<T>
    where
        T: Causable + Clone,
{
    // These methods can be generated by the compiler using macros.
    fn len(&self) -> usize;
    fn is_empty(&self) -> bool;
    fn to_vec(&self) -> Vec<T>;

    // This method must be implemented by the user.
    //  Apply different data to each causaloid i.e 23,45,89 to Q1, Q2,Q2
    // Requires that data and items in the collection have the same order and the same length,
    fn get_all_items(&self) -> Vec<&T>;
    // Default implementations for all other methods are provided below.

    fn explain(&self) -> String {
        let mut explanation = String::new();
        for cause in self.get_all_items() {
            explanation.push_str("\n");
            explanation.push_str(format!(" * {}", cause.explain().unwrap()).as_str());
            explanation.push_str("\n");
        }
        explanation
    }
    fn get_all_causes_true(&self) -> bool {
        for cause in self.get_all_items() {
            if !cause.is_active() {
                return false;
            }
        }

        return true;
    }
    fn get_all_active_causes(&self) -> Vec<&T> {
        self.get_all_items()
            .into_iter()
            .filter(|cause| cause.is_active())
            .collect()
    }
    fn get_all_inactive_causes(&self) -> Vec<&T> {
        self.get_all_items()
            .into_iter()
            .filter(|cause| !cause.is_active())
            .collect()
    }
    fn number_active(&self) -> NumericalValue {
        self.get_all_items()
            .iter()
            .filter(|c| c.is_active()).count() as NumericalValue
    }
    fn percent_active(&self) -> NumericalValue {
        let count = self.number_active();
        let total = self.len() as NumericalValue;
        (count / total) * (100 as NumericalValue)
    }
    fn reason_all_causes(&self, data: &[NumericalValue]) -> Result<bool, CausalityError>
    {
        if self.is_empty() {
            return Err(CausalityError("Causality collection is empty".into()));
        }

        // Emulate the data index assuming that values in the map have the same order as the data.
        // Since HashMap requires key to be Eq and Hash, Its not given that the key is a NumericalValue.'
        let mut i = 0;
        for cause in self.get_all_items().iter()
        {
            let valid = if cause.is_singleton()
            {
                match cause.verify_single_cause(data.get(i).expect("failed to get value")) {
                    Ok(res) => res,
                    Err(e) => return Err(e),
                }
            } else {
                match cause.verify_all_causes(data, None) {
                    Ok(res) => res,
                    Err(e) => return Err(e),
                }
            };

            if !valid {
                return Ok(false);
            }

            i += 1;
        }

        return Ok(true);
    }
}